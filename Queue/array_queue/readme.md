# `array_queue.h` 数组形式实现队列
使用一个大小为`max_size`数组arr来存储和表示队列

# 具体实现
- 使用两个索引值front 和rear分别指向队首和队尾。

## 讨论 "假溢出"
按照顺序存储的方式去存储元素,front和rear都是逐渐增加的.按照这种方式实现,势必会出现rear已经等于了`max_size`但是队列空间却没有使用完的情况.(front因为出队而增加,前面的空间空余出来了).这就是假溢出.
解决"假溢出"有两种方式.
- 每次出队操作后数据都全体移动一次.显然,当数据较大的时候这种操作效率会很低.
- 使用循环队列.即当rear或者front数到了数组最后一个元素时"绕回去"从第0个开始数.![循环队列图示]()
`array_queue.h`采用的是循环队列方式.

## 循环队列的实现
### "+1"绕回去,实现循环
考虑rear
当`rear == max_size`时,rear从头开始计数,可以使用判断语句然后赋值.当然的,更好的方式是使用求余运算.
`rear = (rear+ 1) % max_size` 就实现了rear的自增1.

### 状态表示,讨论队列的"空"和"满"
按照front和rear对应队首和队尾的下标方式表示,存在一个问题:在队列空或者满的情况下都有 `rear==front`.显然不能直接用`rear==font?`这样的方式来判断队列的空和满的情况.
那么我们可以考虑
- 增加一个计数变量,计队列中的项数,然后和`max_size`比较就好了.
- 巧妙的调整一下rear和front的标记的位置.比如:rear 始终是下一个要入队项存入队列后的下标,front 则指恰好是队列的首项下标.这样,rear和font就"错开了".![循环队列的空和满]()
这样我们就有
  - 队列空 front + 1 = rear
  - 队列满 rear = front
  - 队首 arr[front]

# 限制
- 数据类型应当支持operator=。`c_str`类型支持不友好，可以使用`std::string`替代。
- 使用 `const Type & Front(void) const;`前请确保队列不为空.否则返回值是Type类型的默认值(或者是0);
- 应当确保队列大小是`size_t`类型能表示的,而且队列长度不为0
- 默认队列大小为100

# 适用
- 支持opertor= 的数据类型
- $$(0,size\_t]$$ 大小的队列

# 使用示例

# 修改记录
