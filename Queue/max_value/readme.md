#求队列中的最大值
设计一种高效的数据结构,使得他可以完成队列的功能,并求最大值

# 背景
考虑到求解最大值的问题,不由的思考,队列中是否也可以找到一种求解最值的有效方法.

# 问题分析
需要完成以下功能
- 出队
- 入队
- 获得队首元素
- 求得当前队列的最值.

建立起来的结构本质上还是队列,但是多了一项任务-求解最大值.扫描全队,显然是不够高效的.
有了前面的两个内容
1. 求解栈中的最大值
2. 使用栈来模拟队列

本问题的思路会比容易一些了:转变成为了求解两个栈的最大值.

# 问题抽象
使用两个栈 $$s_{in}$$ , $$s_{out}$$ 来分别完成队列的出队入队功能,一个栈$$s_{max}$$ 来记录当前最大值,再出队入队的过程中动态更新最大值栈.

- 栈$$s_{in}$$,$$s_{out}$$来分别完成队列的出队入队功能,这部分内容,同`stack_queue`一致
- 每一次data压栈操作都要影响到 $$s_{max} $$.这个影响称为data设置$$st_{max}$$.
	- data设置$$st_{max}$$ : 如果$$st_{max}$$非空且栈顶元素大于data,复制栈顶元素压入本身.否则用data压入本身. 
- 每次访问队首(以及出队)都需要将队列进行平衡:如果出队栈空,置空最值栈,逐一将入队栈值弹出压入出队栈,并设置最值栈.

- 入队: 即数据data压入$$st_{in}$$ 中. 需要设置$$st_{max}$$.
- 出队: 平衡以后$$st_{out}$$,$$st_{max}$$.弹栈,
- 队首: 如果非空队列,平衡以后$$st_{out}$$的栈顶
- 队尾: $$st_{in}$$ 的栈顶
- 队空: 两个栈都空
- 队满: 任意一个队满

## 调整
使用两个栈以后`bool Front(Type & data) const;`和`const Type & Front(void) const;`需要调整为非`const`成员函数.这是由于需要调整内部栈造成的.
# 效率
## 空间开销
如果栈是数组栈,则至少需要 2n+n的空间.链表栈n+n空间
## 时间开销
入队是$$O(1)$$ 的时间
出队至多是$$o(n)$$
查找最大值是$$O(1)$$

# 依赖项
本实现是利用了自定义的链式结构栈,需要包含头文件`link_stack.h`
见:`\DateStruct2017\Stack\link_stack\link_stack.h\`
# 限制
- 数据类型应当支持operator=。`c_str`类型支持不友好，可以使用`std::string`替代。

# 适用
支持opertor= 的数据类型

# 使用示例

# 修改记录
