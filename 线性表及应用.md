   班    级
   1150310314
   学    号
   1603005
   姓    名
​    黄炼
   指导教师
   李秀坤
   实验地点
   理学楼208
   实验时间
​    哈尔滨工业大学计算机科学与技术学院
​    线性表及应用
​    数据结构与算法Lab1

 目录
 [1.    实验目的... 3](#_Toc498115091)
 [2.   实验内容... 3](#_Toc498115092)
 [3.   实验环境... 3](#_Toc498115093)
 [4.   实验过程... 3](#_Toc498115094)
 [4.1    算术表达式求值... 3](#_Toc498115095)
 [4.1.2   问题分析... 4](#_Toc498115096)
 [4.1.3   设计思想... 5](#_Toc498115097)
 [4.1.4   具体实现过程... 8](#_Toc498115098)
 [4.1.5   主程序流程及图示... 11](#_Toc498115099)
 [4.1.6   测试用例及测试结果... 11](#_Toc498115100)
 [4.1.7   系统缺陷以及优点... 13](#_Toc498115101)
 [4.2   利用两个栈模拟队列的五个操作。... 13](#_Toc498115102)
 [4.2.2   问题分析... 14](#_Toc498115103)
 [4.2.3   设计思想... 14](#_Toc498115104)
 [4.2.4   具体实现过程... 16](#_Toc498115105)
 [4.2.5   主程序流程及图示... 16](#_Toc498115106)
 [4.2.6   测试用例及测试结果... 16](#_Toc498115107)
 [4.2.7   系统缺陷以及优点... 17](#_Toc498115108)
 [4.3   利用两个队列模拟栈的五个操作。... 17](#_Toc498115109)
 [4.3.2   问题分析... 18](#_Toc498115110)
 [4.3.3   设计思想... 19](#_Toc498115111)
 [4.3.4   具体实现过程... 19](#_Toc498115112)
 [4.3.5   主程序流程及图示... 19](#_Toc498115113)
 [4.3.6   测试用例及测试结果... 19](#_Toc498115114)
 [4.3.7   系统缺陷以及优点... 19](#_Toc498115115)
 [5.   实验总结... 19](#_Toc498115116)
 [6.   附录... 19](#_Toc498115117)

# [1.        实验目的]()

# [2.       实验内容]()

1)     算术表达式求值

要求：

键盘可以重复输入中缀算术表达式，编程实现转换成后缀表达式输出，再对该后缀表达式求值计算输出结果。

 

2)    利用两个栈模拟队列的五个操作。

3)    利用两个队列模拟栈的五个操作。

# [3.       实验环境]()

Ø   格物楼208机房。

Ø   Ubuntu下vim gcc gdb make

Ø   C++

# [4.       实验过程]()

## [4.1        算术表达式求值]()

键盘可以重复输入中缀算术表达式，编程实现转换成后缀表达式输出，再对该后缀表达式求值计算输出结果。

算术表达式运算符号包括

\+ - * \ % 

包含括号

()

### [4.1.2     问题分析]()

说明：以下涉及到的运算符号和操作符是同义词。数值和操作数不区分视为同义词。

需要实现三个功能

A.   表达式的输入以及合法性检测。

B.    将中缀表达式转换为后缀表达式，并输出。

C.   计算后缀表达式结果，并输出。

 

1)     表达式的输入以及合法性检测。

输入的一行是一个表达式。

合法的表达式中包括基本的运算符号，括号和数值。合法的表达式是后续的计算的基础。非法表达式中可能包含任何的键盘符号。

其中，数值有整数（一位或者多位），浮点小数。数值有正负的区分，即有-可能是负数的符号，也可能是运算符号。

2)    将中缀表达式转换为后缀表达式，并输出。

中缀表达式运算顺序依据运算符号出现的顺序以及符号的优先度和括号指定的次序计算。

后缀表达式不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。

所以需要依据中缀表达式中各运算的优先顺序以及括号来调整符号在后缀表达式中出现的顺序。

3)    计算后缀表达式结果，并输出。

遇到一个运算符号，取出两个操作数做符号对应的计算，将计算结果保留到操作数序列中。重复这个过程直到求解出表达式。

### [4.1.3     设计思想]()

#### 4.1.3.1 表达式的输入以及合法性检测

图1是对此部分内容概括

\#插入图片# 表达式合法性检查

将一行输入作为一个表达式，即表达式是一个字符串。对输入的字符串的处理几位对表达式的处理。则一个合法的表达式字符串被限定为了以下符号集合的组成。

​         + - * / % 1 2 3 4 5 6 7 89 0

为了允许输入的表达式可读性更好，允许录入空白符号。

凡是包含了不在上述集合中的字符的表达式，都是非法的（无效的）表达式。空白符号在处理时跳过。

 

现在依次的处理字符串的每个字符在表达式中的有效性，藉此判断表达式的有效性。依据问题分析将字符划分为以下4种情况讨论。

Ø  数值。是可以转化为一个操作数的序列，所以是一个或者多个字符的组成。

包括「0~9」，负号「-」，小数点「.」。为了便于分析。将0~9又叫做数。

Ø  括号。一个字符

即左括号「（」和右括号「）」。

Ø  运算符。号一个字符

即 「+-*/%」

Ø  -符号。一个字符。

「-」即使是数值也是「减」运算符号。所以再次的列出来。

 

每个字符的合法与否都依赖于前一个字符或者前一个数值。

1)       数值。一个完整操作数是在遇上一个非数值类型的字符时形成的。

一个数有效的情况：

Ø  没有前一个字符：即出现在表达式的开始。

Ø  前一个字符是一个数值类型的字符，运算符号或者左括号。

 

一个负号有效的情况

为了避免出现两个「-」出现的情况，负数跟在运算符号后面时要求用括号包括。所以一个负号有效的情况是：

Ø  没有前一个字符

Ø  前一个字符是左括号。

一个小数点有效的情况

Ø  前面应当是一个数且在已经形成的数值里没有小数点

 

2)      括号

左括号有效的情况

Ø  作为第一个符号

Ø  跟在一个左括号后面

Ø  跟在一个运算符号后面

右括号有效的情况

Ø  跟在一个数的后面

Ø  跟在一个有效的右括号的后面。

对于整个表达式还需要验证括号的匹配。

 

3)      运算符号

由于使用的都是双操作数的运算符号所以一个运算符号的有效情况应当是

Ø  前面是一个数

Ø  前面是一个右括号。

 

4)      -符号

需要判断是一个减号还是一个负数的符号

Ø 前面是一个运算符号、空白、或者左括号，是负数的符号

Ø 前面是一个数，是减号，

 

注意：对于整个表达式还需要保证括号的匹配。表达式的结束应当是一个完整有效的数值（不仅是「-」或者「.」）或者右括号。

 

#### 4.1.3.2 将中缀表达式转换为后缀表达式，并输出

对中缀表达式从左至右依次扫描

由于操作数的顺序保持不变，当遇到操作数时直接输出到后缀表达式中；

为调整运算顺序，设立一个栈用以保存操作符，扫描到操作符时，将操作符压入栈中。

​    进栈的原则是保持栈顶操作符的优先级要高于栈中其他操作符的优先级。优先级的表示是对于不同优先级的符号给予不同的整数值。具体值见实现部分。

​    否则，将栈顶操作符依次退栈并输出，直到满足要求为止。

​    遇到 “ （ ” 进栈，当遇到 “ ） ” 时，退栈输出直到 “ ） ”为止。

 

#### 4.1.3.3 计算后缀表达式结果，并输出。

建立一个栈S 。从左到右读表达式，如果读到操作数就将它压入栈S中，如果读到n元运算符(即需要参数个数为n的运算符)则取出由栈顶向下的n项按操作数运算，再将运算的结果代替原栈顶的n项，压入栈S中 。如果后缀表达式未读完，则重复上面过程，最后输出栈顶的数值则为结束。

### [4.1.4     具体实现过程]()

#### 4.1.4.1 功能完成情况

Ø   表达式合法性检查

Ø   对括号，负数的处理

Ø   中缀表达式转换为后缀表达式

Ø   对后缀表达式求值

#### 4.1.4.2 具体实现陈诉

##### 数据结构

\#插入图片# Expr头文件

更多细节见附录文件：./Expr/include/expr.h

Ø 表达式的存储

使用单链表来存储表达式，每个节点是一个操作数或者一个操作符。

\```C++ code

//  每一个节点

struct node{

  inttag; // 标记存储的数据是操作数或者操作符号。

​       // 0 操作符。其他，浮点数,

​       // 1整数,

​       // 2浮点数

  union{

   char op;    

​    intn;

   double d;

 }data;

 struct Node * next;

};

Node * infix_； // 中缀表达式

Node * postfix_； // 后缀表达式

double value_ // 保存表达式计算结果

\```

Ø 基本操作

// 显示中缀表达式
void Expr::ShowInfix(void) const；

 

// 显示后缀表达式
void Expr::ShowPostfix(void) const；

 

// 显示表达式计算结果

void Expr::ShowResult(void) const；

 

// 表达式的合法性
bool Expr::is_valid(void) const;

 

 

##### 关键实现

更多细节见附录文件：./Expr/src/expr.cpp

 

// 依据输入的字符串设置中缀表达式以及检测合法性。

// 不合法的表达式设置非法，并且中缀表达式值为0    

void Expr::set_infix_expr(const char *c_str_expr);

\#插入图片# set_infix_expr

 

// 依据中缀表达式来设置后缀表达式    

void Expr::set_postfix_expr(void);

\#插入图片# :set_postfix_expr

 

// 依据后缀表达式来求表达式的值。    

void Expr::set_value(void);

\#插入图片# set_value

 

### [4.1.5     主程序流程及图示]()

\#插入图片# 主程序流程及图示

### [4.1.6     测试用例及测试结果]()

#### 4.1.6.1 合法用例

包含全部运算符号，以及负数，小数，括号的测试

\#插入图片#包含全部运算符号，以及负数，小数，括号的测试

负数开始

\#插入图片#负数开始

负数在表达式中间，

\#插入图片#负数在表达式中间，

减去一个负数

\#插入图片#减去一个负数。

负的小数

\#插入图片# 负的小数

 

#### 4.1.6.2 特殊情况：除零错误

a)    除以输入的0

\#插入图片# 除以 输入的0

b)   除以运算过程中得到的0

\#插入图片# 除以 运算过程中得到的0

#### 4.1.6.3 边界条件

a)    过大的长度

\#插入图片# 过大的长度

b)   1长度

\#插入图片# 1长度

c)    0长度

\#插入图片# 0长度

#### 4.1.6.4 非法用例

a)    非法表达式符号

\#插入图片# 非法表达式符号

b)   括号

括号不匹配

\#插入图片# 括号不匹配

包含空括号

\#插入图片# 包含空括号

c)    以. – 结尾

\#插入图片# 以.  结尾

\#插入图片# 以– 结尾

d)   运算符号重复

\#插入图片#连续两个—

e)    只有运算符号

\#插入图片#只有运算符号

### [4.1.7     系统缺陷以及优点]()

## [4.2       利用两个栈模拟队列的五个操作。]()

利用两个栈模拟队列的五个操作。

已知栈的操作：

Ø Push()

Ø Pop()

Ø Top()

Ø MakeNull()

Ø IsEmpty()

Ø IsFull()

据此实现队列操作

Ø EnQueue()

Ø DeQueue()

Ø Front()

Ø MakeNull()

Ø IsEmpty()

Ø IsFull()

 

### [4.2.2    问题分析]()

栈的特性是后进先出，队列特性是先进先出。

核心问题是

l 如何由入栈转换为入队（栈顶-队尾）。

l 如何由出栈转换为出队（栈顶-队首）。

栈始终是对栈顶操作。一个栈无法完成对队列的模拟，再添加一个栈来缓存数据。假定栈不会溢出。

### [4.2.3    设计思想]()

#### 4.2.3.1 思考1 入栈等价于入队。、

即考虑入队就是直接将新元素压入的栈中，不进行栈的其他操作。

Ø 入队：假定栈低到栈顶的顺序即为队首到队尾。则

n 数据压入栈S1，

Ø 出队：

n 两个栈都为空，出队失败。

n 否则，S1的数据逐一取出并压入到S2空栈中。此时S2栈顶即为队首。栈S2进行一次出栈操作即为出队。再次将栈S2元素逐一取出压入原来的栈S1中，保持S1栈顶可入队。

#### 4.2.3.2 思考2 出栈等价于出队。

即考虑出队就是直接从栈中弹出一个元素，不进行栈的其他操作。

Ø 出队：假定栈顶到栈底的顺序即为队首到队尾的顺序。

n 如果两个栈都空，出队失败

n 否则，S1栈顶即为队首，栈S1进行一次出栈操作即为出队。

Ø 入队：

n 如果两个栈都空，将数据压入到其中一个栈S2。

n 否则，S1栈底即为队尾。将栈S1数据逐一取出压入空栈S2，然后将新数据压入S1，即入队，然后将原来的数据压回S1。即保持S1栈顶为可出队状态。

#### 4.2.3.3 思考3更加优化的方案。入栈即入队，出栈即出队。

可以看出思考1和思考2都始终的维护S1，S2仅仅是作为缓存的作用。都存在需要将数据「倒」两次的情况：即将原来的数据倒入空栈S2中，操作好了，再将数据倒回原来的栈S1中。现在考虑能否不重复倒。其中思考2要比思考1稍微好一点，因为访问队首是比较容易的（取队首）。能否减少转移数据呢？

考虑在栈S1中，栈顶即为队尾，在栈S2中，S2非空，栈顶即队首。则:

Ø 入队：数据直接压入栈S1

Ø 出队：

n 如果S2非空，出队即可

n 否则，将S1的数据逐一取出压入S2中，S2出栈即可。

### [4.2.4    具体实现过程]()

#### 4.2.4.1 功能完成情况

全部5个功能

#### 4.2.4.2 具体实现陈诉

### [4.2.5    主程序流程及图示]()

### [4.2.6    测试用例及测试结果]()

#### 入队

空队列

\#插入图片#空队列入队

非空队列

\#插入图片#非空队列入队

#### 出队

空队列

\#插入图片#空队列出队

非空队列

\#插入图片#非空队列出队

#### 访问队首

空队列

\#插入图片#空队列访问队首

非空队列

\#插入图片#非空队列访问队首

#### 混合测试

### [4.2.7    系统缺陷以及优点]()

## [4.3       利用两个队列模拟栈的五个操作。]()

利用两个队列模拟栈的五个操作。

已知队列的

Ø EnQueue()

Ø DeQueue()

Ø Front()

Ø MakeNull()

Ø IsEmpty()

Ø IsFull()

据此实现栈操作

Ø Push()

Ø Pop()

Ø Top()

Ø MakeNull()

Ø IsEmpty()

Ø IsFull()

### [4.3.2    问题分析]()

栈的特性是后进先出，队列特性是先进先出。

核心问题是

l 如何由入队转换为入栈（队尾-栈顶）

l 如何由出队转换为出栈（队首-栈顶）

### [4.3.3    设计思想]()

#### 4.3.3.1思考1 入队等价于入栈

入队即实现入栈。不进行其他队列操作。

入栈：

#### 4.3.3.2思考2 出队等价于出栈

出队操作即实现出队[栈操作，不进行其他队列操作。]()

### 4.3.4    具体实现过程

#### 4.3.4.1功能完成情况

#### 4.3.4.2具体实现陈诉

### [4.3.5    主程序流程及图示]()

### [4.3.6    测试用例及测试结果]()

### [4.3.7    系统缺陷以及优点]()

# [5.       实验总结]()

# [6.       附录]()